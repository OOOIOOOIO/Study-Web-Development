> 문득... 동기화를 공부하면서 어... 스프링도 멀티 쓰레드 환경일텐데... 뭐지? 싶어서 구글링을 막 해버렸다..

<br>

# 멀티쓰레드 환경과 스프링 빈
> &nbsp;스프링 빈은 대부분 Singleton 패턴으로 생성되어 Application Context에 의해 관리된다. 즉 모든 Controller, Service, Repository 등과 같은 빈들은 하나의 인스턴스만 생성된다.<br>
> &nbsp;그런데 스프링환경 자체는 멀티 쓰레드인데, 어떻게 Thread-Safe를 유지할 수 있을까? 여기에 대한 대답은 당연히 Thread-Safe하지 않지만 Thread-Safe 하도록 코드를 짤 뿐이라는 것이다.

<br>
<hr>
<br>

# 구조
![image](https://user-images.githubusercontent.com/74396651/220053382-b36fa5ea-7143-478b-8540-30273ad52b1f.png)
- 요청이 들어오면 각 요청에 대해 하나의 쓰레드가 할당되게 된다.
- 모든 쓰레드는 스프링 빈을 공유하고 내부의 멤버변수도 공유하게 되는 것이다.

<br>
<hr>
<br>

# 예제
```java
@RestController
public class UserController {

    private final UserRepository userRepository;
    private Long n = 0L;

    public UserController(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @GetMapping(value = "/hello")
    @Transactional
    public Long getUser() throws NotFoundException, InterruptedException {
        return userRepository.save(new User(++n,"user"+n)).orElseThrow(() -> new NotFoundException("존재하지 않습니다."));
    }
}
```
- 위 예시는 단순히 repository에 저장하는 코드다. 
- "/hello" 요청이 들어올 때마다 user가 저장되고 id값이 하나씩 증가한다.

![image](https://user-images.githubusercontent.com/74396651/220053973-9411c2fe-022e-465b-934a-b88259ed1da0.png)

<hr>

- 위 사진에서는 문제없이 잘 저장이 된 것을 확인할 수 있다.
- 하지만 다수의 요청이 동시에 들어왔을 때를 확인해보면 아래 사진처럼 id값이 중복되는 것을 확인할 수 있다.
- 즉 Thread-Safe 하지 않다는 것이다.

![image](https://user-images.githubusercontent.com/74396651/220054273-5f70ccba-9cdf-4af5-9147-a36eac1ec14b.png)

<br>
<hr>
<br>

## 그동안 어떻게 문제없이 사용했을까
> &nbsp;그 이유는 객체가 상태를 가지지 않는 불변객체였기 때문이다. 보통 @Component, @Controller, @Repository와 같은 곳에서 사용하는 객체들은 "주입"을 받아서 사용하고 내부적으로 멤버 변수를 가지고 변화시키지 않는다.<br>
> &nbsp;스프링빈을 Thread-Safe하게 사용하기 위해서는 스프링 빈으로 주입되는 클래스는 모두 불변 객체여야 한다.<br>
> &nbsp;아니면 스프링빈의 스코프를 Prototype으로 만들면 해당 빈이 불릴 때마다 새로운 객체가 생성되게 된다.


<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

[참고](https://doflamingo.tistory.com/44)

