# Proxy
> &nbsp;JPA 구현체들은 연관된 객체들을 처음부터 데이터베이스에서 조회하는 것이 아니라, 실제 사용하는 시점에 데이터베이스에서 조회할 수 있다. 이것이 가능한 이유는 프록시 때문이다. 프록시를 통해서 즉시로딩(EAGER)과 지연로딩(LAZY)을 사용하여 보다 유연하게 개발할 수 있다.<br><br>
> &nbsp;JPA 표준 명세는 지연 로딩 구현방법을 JPA 구현체에 위임한다. 하이버네이트는 지연로딩(LAZY)을 지원하는 방법으로 프록시 방법과 바이트코드 수정 방법 이 두 가지 방법을 제공한다.(바이트코드를 수정하는 방법은 복잡하다.)

<br>

## JPA에서의 Proxy
- 실제 클래스를 상속 받아 만들어지며 겉 모양이 같다.
- 사용하는 입장에서 진짜 객체인지 프록시 객체인지 신경쓰지 않고 사용하면 된다.
![image](https://user-images.githubusercontent.com/74396651/203362563-8947fa64-de9e-4a00-8bc2-98f4c94cf14f.png)

- 프록시 객체는 실제 객체의 참조(target)를 보관하고 있다.
- 프록시 객체르 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
![image](https://user-images.githubusercontent.com/74396651/203362774-76e478e9-9fd0-47a4-9db8-b782492ab813.png)

- 프록시 객체는 처음 사용할 때 한 번만 초기화 된다.
- 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 변하는 것이 아니다. 초기화가 되면 프록시 객체를 통해 실제 엔티티로 접근하는 것이다.

![image](https://user-images.githubusercontent.com/74396651/203364081-45a9843b-db63-47c2-a468-e77bbe830fc9.png)

- 프록시 객체는 원본 엔티티를 상속받기 때문에 타입 체크시 주의해야 한다.
   - == 대신 instance of를 사용해야 한다.
- 영속성 컨텍스트에 찾는 엔티티가 이미 있다면 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다. 
- 영속성 컨텍스트 안이 아닌 준영속 상태일 때 프록시를 초기화하면 문제가 발생한다.(Transaction 내에서 사용하자 꼭! 그렇지 않으면  org.hibernate.LazyInitializationException 예외가 발생한다.)

<br>

## 프록시 확인하기

# 즉시로딩, 지연로딩

# CASCADE
