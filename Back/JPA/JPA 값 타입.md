# JPA 값 타입 분류
- 기본값 타입
- 임베디드 타입(복합 값 타입)
- 값 타입과 불변 객체
- 값 타입의 비교
- 값 타입 컬렉션

<hr>

# JPA에서의 데이터 타입 분류
- 엔티티 타입
   - @Entity로 정의하는 객체
   - 데이터가 변해도 식별자로 추적 가능
   - ex) 회원 엔티티의 키 or 나이를 변경해도 식별자로 인식 가능
- 값 타입
   - int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
   - 식별자가 없고 값만 있으므로 변경시 추적 불가
   - ex) 숫자 100 -> 200으로 변경하면 완전히 다른 값으로 대체된 것이다.

<br>
<hr>
<br>

# 기본값 타입
- ex) int age, String name, Long length, ...
- 생명주기를 엔티티에 의존한다.
   - 회원을 삭제하면 회원의 이름, 나이, ... 필드도 함께 삭제
 - 값 타입은 공유되면 안된다.
   - 회원 이름 변경시 다른 회원의 이름에 영향을 미치면 안된다.
 - Java의 int, double과 같은 기본 타입(primitive type)은 값을 복사한다.(절대 공유하지 않는다)
 - Java의 Integer, Long과 같은 래퍼 클래스나 String 같은 클래스는 공유 가능한 객체이지만 변경되지 않는다.(다른 객체에 영향을 받지 않는다)

```java
int a = 20;
int b = a;

a = 50;
//--> a = 50, b = 20

Integer c = 40;
Integer d = c;

c = 50;
// --> c = 50, d = 40;

```

<hr>
<br>
<hr>

# 임베디드 타입(복합 값 타입)
- 새로운 값 타입을 직접 정의할 수 있다.
- JPA는 임베디드 타입(embedded type)이라 정의한다.
- 주로 기본 값 타입을 모아 만들어 복합 값 타입이라고도 한다.(객체)
- 임베디드 타입의 값이 null이면 매핑한 컬럼 값 모두 null이 들어간다.
![image](https://user-images.githubusercontent.com/74396651/200153903-82839f38-84d1-4f06-8f8a-0a02fd0b41ea.png)

![image](https://user-images.githubusercontent.com/74396651/200153897-9925365b-bae1-4d29-aa04-6d92e219b118.png)

## 사용법
- @Embeddable : 값 타입을 정의하는 곳에 표시
- @Embedded : 값 타입을 사용하는 곳에서 표시(Entity에서)
    - 얘는 생략 가능!
- 기본 생성자 필수!

<br>

## 장점
- 재사용성
- 높은 응집도
- 해당 값 타입만 사용하여 의미 있는 메소드를 만들 수 있음
- 임베디드 타입을 포함한 모든 값 타입은 "Entity에 생명주기"를 의존한다.

<br>

## 테이블 매핑
- 임베디드 타입은 엔티이의 값(필드)일 뿐이다.
- 임베디드 타입을 사용하기 전과 후나 매핑하는 테이블은 같다.
- 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능하다.
- 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

![image](https://user-images.githubusercontent.com/74396651/200154106-c15b47ee-fb42-4b35-baa4-c0e51b25d3bc.png)

<br>

## 속성 재정의 : @AttributeOverride
- 한 엔티티에서 같은 값 타입을 사용하면 컬렴명이 중복된다. 이 때 사용한다.
- @AttributeOverrides(@AttributeOverride)를 사용해 컬럼 명 속성을 재정의 한다.

<br>

## 값 타입 공유 참조 및 한계
- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 부작용(side effect)가 발생하여 위험하다.
- 객체 타입의 공유 참조는 피할 수 없다.(Java
![image](https://user-images.githubusercontent.com/74396651/200154284-2b2a74f6-a494-4310-8a40-451019ee0d47.png)

- 값 타입의 실제 인스턴스 값을 공유하는 것은 위험하기 때문에 인스턴스를 새로 만들던가 복사하여 사용한다.

![image](https://user-images.githubusercontent.com/74396651/200154288-9b29eab5-b9ce-44cd-854c-e32e840d3a2e.png)

<br>

## 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체
- 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단할 수 있다.
- 값 타입은 불변 객체(immutable object)로 설계해야 한다.
- 생성자로만 값을 설정하고 수정자(Setter)를 막아야 한다.
- 그리고 객체를 복사해서 사용한다.

## 값 타입 비교
- 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 한다.
- 동일성(identity) 비교 : 인스턴스 참조 값을 비교, ==
- 동등성(equivalence) 비교 : 인스턴스 값 비교, equals()
    - 값 타입은 equals()를 사용해 동등성을 비교해야 한다.
    - 값 타입의 equals(), hashcode()를 적절히 재정의 해주어야 한다.(주로 모든 필드 사용)
![image](https://user-images.githubusercontent.com/74396651/199898752-1f220e02-c500-41bf-b3ba-aabdd86698d8.png)

<br>

## 값 타입 컬렉션
- 값 타입을 하나 이상 저장할 때 사용
- @ElementCollection, @CollectionTable 사용
- DB에는 컬렉션을 저장할 수 없으므로 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.

<br>

## 컬렉션 제약사항
- 값 타입은 엔티티와 다르게 식별자 개념이 없어 변경할 시 추적이 어렵다.
- 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고 컬렉션에 있는 현재 값을 모두 다시 저장한다.
- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묵어서 기본 키를 구성해야 한다. 
- null 허용 X, 중복 저장 X  충족

![image](https://user-images.githubusercontent.com/74396651/199896358-70836fd3-ec76-4bcd-aa43-983a7da19be6.png)

<br>

## 컬렉션 대안
- 실무에서는 상황에 따라 값 타입 컬렉션 대신 일대다( 1 : N ) 관계를 고려해야 한다.
- 일대다(1 : N) 관계를 위한 엔티티(N)를 만들고, 여기서 값 타입을 사용한다.(Entity로 승격)
- 영속성 전이(Casacade) + 고아 객체 제거를 사용해 값 타입 컬렉션처럼 사용한다.
- 
![image](https://user-images.githubusercontent.com/74396651/199901671-8aba57a8-8049-45ca-aed5-e897023bc4da.png)

<br>

# 정리
- 엔티티 타입 특징
    -  식별자 O
    -  생명 주기 관리
    -  공유
-  값 타입 특징
    -  식별자 X
    -  생명 주기를 엔티티에 의존
    -  공유하지 않는 것이 안전(복사해서 사용)
    -  불변 객체로 만드는 것이 안전
- 값 타입은 정말 값 타입이라 판단될 때만 사용
- 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안된다.
- 식별자가 필요하고, 지속해서 값을 추적해야 하며, 변경해야 한다면 그것은 Entity이다.

<br>
<hr>
<br>

참조
인프런 김영한님 강의
